/**
 *  Copyright (C) 2018  foxis (Andrius Mikonis <andrius.mikonis@gmail.com>)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

#include "ControllerBase.h"


ControllerBase::ControllerBase(Config &cfg, Adafruit_SSD1306 &display) : config(cfg),
															pidTemperature(&_temperature, &_target_control, &_target, .5 / DEFAULT_TEMP_RISE_AFTER_OFF, 5.0 / DEFAULT_TEMP_RISE_AFTER_OFF, 4 / DEFAULT_TEMP_RISE_AFTER_OFF, DIRECT),
															aTune(&_temperature, &_target_control, &_target, &_now, DIRECT),
															thermocouple(thermoCLK, thermoCS, thermoDO)
{
	this->display = display;
	_readings.reserve(15 * 60);

	_calP = .5 / DEFAULT_TEMP_RISE_AFTER_OFF;
	_calD = 5.0 / DEFAULT_TEMP_RISE_AFTER_OFF;
	_calI = 4 / DEFAULT_TEMP_RISE_AFTER_OFF;

	pidTemperature.SetSampleTime(config.measureInterval * 1000);
	pidTemperature.SetMode(AUTOMATIC);
	pidTemperature.SetOutputLimits(0, 1);

	_setPinMode(RELAY, OUTPUT);

	_setPinValue(RELAY, LOW);

	_mode = _last_mode = INIT;
	_temperature = 0;
	_target = DEFAULT_TARGET;
	_onMessage = NULL;
	_onMode = NULL;
	_onReadingsReport = NULL;
	_locked = false;
	_last_heater_on = 0;

	_heater = _last_heater = false;

	// TODO sound

	// TODO tone(BUZZER_A, 440, 100);

	setPID("default");

	_temperature = _read_temperature();

	S_printf("Current temperature: %f\n", _temperature);
	_readings.push_back(temperature_to_log(_temperature));
}

void ControllerBase::loop(unsigned long now)
{

	if (now - last_m > config.measureInterval)
	{
		if (_last_mode == _mode && _mode >= ON)
		{
			handle_measure(now);
		}else {
			_read_temperature();
			last_m = now;
		}
	}

	switch (_mode)
	{
	case INIT:
		callMessage("%s Initialized and ready", name());
		line1 = "init";
		mode(OFF);
		break;
	case ON:
		line1 = "ON";
		// callMessage("WARNING: Heater is on until turned off");
		_heater = true;
		break;
	case ERROR_OFF:
	case OFF:
		line1 = "OFF";
		// callMessage("WARNING: Heater is on until turned off");
		_heater = false;
		break;
	case TARGET_PID:
		line1 = "TARGET_PID";
		handle_pid(now);
		break;
	case REFLOW:
		line1 = "REFLOW";
		handle_reflow(now);
		break;
	case CALIBRATE:
		line1 = "CALIBRATE";
		handle_calibration(now);
		break;
	case CALIBRATE_COOL:
	case REFLOW_COOL:
		line1 = "COOLdown";
		_heater = false;
		if (_temperature < SAFE_TEMPERATURE)
		{
			callMessage("INFO: Temperature has reached safe levels (<%.2f*C). Max temperature: %.2f", (float)SAFE_TEMPERATURE, (float)_CALIBRATE_max_temperature);
			mode(OFF);
		}
	}

	handle_mode(now);

	handle_safety(now);

	_setPinValue(RELAY, _heater);

	if (_onHeater && _heater != _last_heater)
		_onHeater(_heater);
	_last_heater = _heater;

	draw();
}

float ControllerBase::_read_temperature()
{
	float tmp = thermocouple.readCelsius();
	line2 = String((int)round(tmp)) + char(0xf7);
	return tmp;
}

void ControllerBase::_setPinMode(int pin, int mode)
{
	pinMode(pin, mode);
}

void ControllerBase::_setPinValue(int pin, int value)
{
	digitalWrite(pin, value);
}

PID &ControllerBase::setPID(float P, float I, float D)
{
	resetPID();
	pidTemperature.SetTunings(P, I, D);
	return pidTemperature;
}

PID &ControllerBase::setPID(const String &name)
{
	if (config.pid.find(name) == config.pid.end())
	{
		callMessage("WARNING: No PID named '%s' found!!", name.c_str());
		return pidTemperature;
	}
	else
	{
		callMessage("INFO: Setting PID to '%s'.", name.c_str());
		return setPID(config.pid[name].P, config.pid[name].I, config.pid[name].D);
	}
}

void ControllerBase::resetPID()
{
	pidTemperature.Reset();
}

String ControllerBase::calibrationString()
{
	char str[64] = "";
	sprintf(str, "[%f, %f, %f]", _calP, _calI, _calD);
	return str;
}

const char *ControllerBase::translate_mode(MODE_t mode)
{
	MODE_t m = mode == UNKNOWN ? _mode : mode;
	switch (m)
	{
	case INIT:
		return "Init";
		break;
	case ON:
		return "ON";
		break;
	case OFF:
		return "OFF";
		break;
	case CALIBRATE:
		return "Calibrating 1";
		break;
	case TARGET_PID:
		return "Keep Target";
		break;
	case CALIBRATE_COOL:
		return "Cooldown";
		break;
	case ERROR_OFF:
		return "Error";
		break;
	case REFLOW:
		return "Reflow";
		break;
	case REFLOW_COOL:
		return "Cooldown";
		break;
	default:
		return "default";
	}
}

ControllerBase::Temperature_t ControllerBase::temperature_to_log(float t)
{
	return t; // TODO: convert to 16bit fixed point
}

float ControllerBase::log_to_temperature(ControllerBase::Temperature_t t)
{
	return isnan(t) ? 0.0 : t;
}

float ControllerBase::measure_temperature(unsigned long now)
{
	if (now - last_m > config.measureInterval * 1.1)
	{
		last_m = now;
		return temperature(_read_temperature());
	}
	else
		return temperature();
}
unsigned long ControllerBase::elapsed(unsigned long now)
{
	return now - _start_time;
}

void ControllerBase::callMessage(const char *format, ...)
{
	char buffer[512];
	va_list args;
	va_start(args, format);
	vsnprintf(buffer, sizeof(buffer), format, args);
	if (_onMessage)
		_onMessage(buffer);
	Serial.println(buffer);
	va_end(args);
}

void ControllerBase::reportReadings(unsigned long now)
{
	if (_onReadingsReport)
		_onReadingsReport(_readings, now);
}

void ControllerBase::handle_mode(unsigned long now)
{
	if (_last_mode <= OFF && _mode > OFF)
	{
		_start_time = now;
		_temperature = _read_temperature();
		pidTemperature.Reset();
		_readings.clear();
		_readings.push_back(temperature_to_log(_temperature));
		reportReadings(now - _start_time);
		last_m = now;
		last_log_m = now;
		_avg_rate = 0;

		if (_mode == CALIBRATE)
		{
			_target_control = config.tuner_init_output; // initial output
			//_temperature = _target;		// target temperature
			aTune.Cancel();								   // just in case
			aTune.SetNoiseBand(config.tuner_noise_band);   // noise band +-1*C
			aTune.SetOutputStep(config.tuner_output_step); // change output +-.5 around initial output
			aTune.SetControlType(config.tuner_id);
			aTune.SetLookbackSec(config.measureInterval * 100);
			aTune.SetSampleTime(config.measureInterval);

			_now = now;
			aTune.Runtime(); // initialize autotuner here, as later we give it actual readings
		}
		else if (_mode == TARGET_PID)
		{
			setPID("default");
			pidTemperature.Reset();
		}
	}
	else if (_mode <= OFF && _last_mode > OFF)
	{
		_temperature = _read_temperature();
		_readings.push_back(temperature_to_log(_temperature));
		if (_last_mode == REFLOW || _last_mode == REFLOW_COOL)
			setPID("default");
		reportReadings(now - _start_time);
	}
	if (_onMode && _last_mode != _mode)
	{
		_onMode(_last_mode, _mode);
	}
	_last_mode = _mode;
}

void ControllerBase::handle_measure(unsigned long now)
{
	double last_temperature = _temperature;
	_temperature = _read_temperature();
	double rate = 1000.0 * (_temperature - last_temperature) / (double)config.measureInterval;
	_avg_rate = _avg_rate * .9 + rate * .1;

	last_m = now;
	if (_mode != CALIBRATE)
	{
		pidTemperature.Compute(now * 1000);
		_target_control = max(_target_control, 0.0);
	}

//	callMessage("DEBUG: PID: <code>e=%f     i=%f     d=%f       Tt=%f       T=%f     C=%f     rate=%f</code>",
//				pidTemperature._e, pidTemperature._i, pidTemperature._d, (float)_target, (float)_temperature, (float)_target_control, (float)_avg_rate);

	if (now - last_log_m > config.reportInterval)
	{
		_readings.push_back(temperature_to_log(_temperature));
		last_log_m = now;
		reportReadings(now - _start_time);
	}
}

void ControllerBase::handle_safety(unsigned long now)
{
	if (!_heater)
	{
		_last_heater_on = now;
		return;
	}

	double factor = _mode == CALIBRATE ? 6 : 1;

	if (now - _last_heater_on > MAX_ON_TIME * factor && _temperature > SAFE_TEMPERATURE)
	{
		mode(ERROR_OFF);
		_heater = false;
		callMessage("ERROR: Heater time limit exceeded (%i seconds)", (int)(MAX_ON_TIME / 1000));
	}

	if (_temperature > MAX_TEMPERATURE)
	{
		mode(ERROR_OFF);
		_heater = false;
		callMessage("ERROR: Temperature limit exceeded");
	}

	if (isnan(_temperature))
	{
		mode(ERROR_OFF);
		_heater = false;
		callMessage("ERROR: Error reading temperature. Check the probe!");
	}

	if (now - _start_time > MIN_TEMP_RISE_TIME && _temperature - _readings[0] < MIN_TEMP_RISE && _temperature < SAFE_TEMPERATURE)
	{
		mode(ERROR_OFF);
		_heater = false;
		callMessage("ERROR: Temperature did not rise for %i seconds!", (int)(MIN_TEMP_RISE_TIME / 1000));
	}
}

void ControllerBase::handle_pid(unsigned long now)
{
	bool one = ((now - last_m < config.measureInterval * _target_control) && (_target_control > CONTROL_HYSTERISIS));
	bool two = now - last_m >= config.measureInterval * _target_control && _target_control > 1.0 - CONTROL_HYSTERISIS;
	_heater = one || two;
	Serial.print("Heater debug");
	Serial.print(_heater);
	Serial.print(" ");
	Serial.print(one);
	Serial.print(" ");
	Serial.println(two);
}

void ControllerBase::handle_calibration(unsigned long now)
{
	_now = now;
	if (aTune.Runtime())
	{
		_heater = false;
		mode(CALIBRATE_COOL);
		_calP = aTune.GetKp();
		_calI = aTune.GetKi();
		_calD = aTune.GetKd();
		callMessage("INFO: Calibration data available! PID = [%f, %f, %f]", _calP, _calI, _calD);
	}

	handle_pid(now);

	_CALIBRATE_max_temperature = max(_CALIBRATE_max_temperature, _temperature);
}
